import { createClient } from '@/lib/supabase/server'
import { type SearchResult } from '@/lib/types/search'

export interface SourceInput {
  id?: string // UUID will be auto-generated by Supabase
  session_id: string
  message_id?: string
  url: string
  title: string
  content: string
  relevance: number
  metadata: Record<string, any>
  created_at?: string // Will be set by Supabase default
}

export async function saveSearchResultsToSupabase(
  sessionId: string,
  messageId: string | undefined,
  results: SearchResult[]
): Promise<SourceInput[]> {
  if (!sessionId) {
    throw new Error('Session ID is required')
  }

  if (!results || !Array.isArray(results)) {
    throw new Error('Invalid results format: expected an array of search results')
  }

  console.log('Processing search results for Supabase:', {
    sessionId,
    messageId,
    resultCount: results.length
  })
  
  const supabase = await createClient()

  // First verify that the research session exists and belongs to the current user
  const { data: session, error: sessionError } = await supabase
    .from('research_sessions')
    .select('id, user_id')
    .eq('id', sessionId)
    .single()

  if (sessionError) {
    console.error('Error verifying research session:', sessionError)
    throw new Error(`Failed to verify research session: ${sessionError.message}`)
  }

  if (!session) {
    throw new Error('Research session not found')
  }
  
  // Map search results to source inputs with proper schema alignment
  const sourceInputs: SourceInput[] = results.map((result) => {
    // Validate required fields
    if (!result.url) {
      throw new Error('URL is required for each search result')
    }

    return {
      session_id: sessionId,
      message_id: messageId,
      url: result.url,
      title: result.title || 'Untitled',
      content: result.content || result.snippet || '',
      relevance: result.relevance || 0,
      metadata: {
        source_type: 'web',
        last_updated: new Date().toISOString(),
        language: result.language || 'en',
        word_count: result.wordCount || 0,
        keywords: result.keywords || [],
        fetch_metadata: {
          status_code: result.status || 200,
          content_type: result.contentType || 'text/html',
          encoding: result.encoding || 'utf-8'
        }
      }
    }
  })

  console.log('Prepared source inputs:', {
    count: sourceInputs.length,
    sample: sourceInputs[0]
  })

  try {
    // Insert all sources in a single transaction
    const { data, error } = await supabase
      .from('sources')
      .insert(sourceInputs)
      .select() // Return the inserted records

    if (error) {
      console.error('Error inserting sources to Supabase:', error)
      throw new Error(`Failed to insert sources: ${error.message}`)
    }

    console.log('Successfully inserted sources to Supabase:', {
      insertedCount: data?.length
    })

    return data
  } catch (error) {
    console.error('Unexpected error while saving sources:', error)
    throw error
  }
}

export async function getSourcesBySession(sessionId: string) {
  const supabase = await createClient()
  
  const { data, error } = await supabase
    .from('sources')
    .select('*')
    .eq('session_id', sessionId)
    .order('relevance', { ascending: false })

  if (error) {
    console.error('Error fetching sources:', error)
    throw new Error(`Failed to fetch sources: ${error.message}`)
  }

  return data
}

export async function getSourcesByMessage(messageId: string) {
  const supabase = await createClient()
  
  const { data, error } = await supabase
    .from('sources')
    .select('*')
    .eq('message_id', messageId)
    .order('relevance', { ascending: false })

  if (error) {
    console.error('Error fetching sources:', error)
    throw new Error(`Failed to fetch sources: ${error.message}`)
  }

  return data
} 